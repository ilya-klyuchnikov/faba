<root>
  <item name="java.util.regex.ASCII ASCII()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val val="pure=true"/>
    </annotation>
  </item>
  <item name="java.util.regex.ASCII boolean isAlnum(int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val val="pure=true"/>
    </annotation>
  </item>
  <item name="java.util.regex.ASCII boolean isAlpha(int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val val="pure=true"/>
    </annotation>
  </item>
  <item name="java.util.regex.ASCII boolean isAscii(int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val val="pure=true"/>
    </annotation>
  </item>
  <item name="java.util.regex.ASCII boolean isCntrl(int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val val="pure=true"/>
    </annotation>
  </item>
  <item name="java.util.regex.ASCII boolean isDigit(int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val val="pure=true"/>
    </annotation>
  </item>
  <item name="java.util.regex.ASCII boolean isGraph(int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val val="pure=true"/>
    </annotation>
  </item>
  <item name="java.util.regex.ASCII boolean isHexDigit(int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val val="pure=true"/>
    </annotation>
  </item>
  <item name="java.util.regex.ASCII boolean isLower(int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val val="pure=true"/>
    </annotation>
  </item>
  <item name="java.util.regex.ASCII boolean isOctDigit(int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val val="pure=true"/>
    </annotation>
  </item>
  <item name="java.util.regex.ASCII boolean isPrint(int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val val="pure=true"/>
    </annotation>
  </item>
  <item name="java.util.regex.ASCII boolean isPunct(int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val val="pure=true"/>
    </annotation>
  </item>
  <item name="java.util.regex.ASCII boolean isSpace(int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val val="pure=true"/>
    </annotation>
  </item>
  <item name="java.util.regex.ASCII boolean isType(int, int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val val="pure=true"/>
    </annotation>
  </item>
  <item name="java.util.regex.ASCII boolean isUpper(int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val val="pure=true"/>
    </annotation>
  </item>
  <item name="java.util.regex.ASCII boolean isWord(int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val val="pure=true"/>
    </annotation>
  </item>
  <item name="java.util.regex.ASCII int getType(int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val val="pure=true"/>
    </annotation>
  </item>
  <item name="java.util.regex.ASCII int toDigit(int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val val="pure=true"/>
    </annotation>
  </item>
  <item name="java.util.regex.ASCII int toLower(int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val val="pure=true"/>
    </annotation>
  </item>
  <item name="java.util.regex.ASCII int toUpper(int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val val="pure=true"/>
    </annotation>
  </item>
  <item name="java.util.regex.Matcher Matcher(java.util.regex.Pattern, java.lang.CharSequence) 0">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Matcher boolean hasAnchoringBounds()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val val="pure=true"/>
    </annotation>
  </item>
  <item name="java.util.regex.Matcher boolean hasTransparentBounds()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val val="pure=true"/>
    </annotation>
  </item>
  <item name="java.util.regex.Matcher boolean hitEnd()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val val="pure=true"/>
    </annotation>
  </item>
  <item name="java.util.regex.Matcher boolean requireEnd()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val val="pure=true"/>
    </annotation>
  </item>
  <item name="java.util.regex.Matcher int groupCount()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val val="pure=true"/>
    </annotation>
  </item>
  <item name="java.util.regex.Matcher int regionEnd()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val val="pure=true"/>
    </annotation>
  </item>
  <item name="java.util.regex.Matcher int regionStart()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val val="pure=true"/>
    </annotation>
  </item>
  <item name="java.util.regex.Matcher java.lang.String group()">
    <annotation name="org.jetbrains.annotations.Nullable"/>
  </item>
  <item name="java.util.regex.Matcher java.lang.String group(int)">
    <annotation name="org.jetbrains.annotations.Nullable"/>
  </item>
  <item name="java.util.regex.Matcher java.lang.String group(java.lang.String) 0">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Matcher java.lang.String group(java.lang.String)">
    <annotation name="org.jetbrains.annotations.Nullable"/>
  </item>
  <item name="java.util.regex.Matcher java.lang.String quoteReplacement(java.lang.String) 0">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Matcher java.lang.String quoteReplacement(java.lang.String)">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Matcher java.lang.String replaceFirst(java.lang.String) 0">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Matcher java.lang.String toString()">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Matcher java.lang.StringBuffer appendTail(java.lang.StringBuffer) 0">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Matcher java.lang.StringBuffer appendTail(java.lang.StringBuffer)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val val="&quot;!null-&gt;!null&quot;"/>
    </annotation>
  </item>
  <item name="java.util.regex.Matcher java.util.regex.MatchResult toMatchResult()">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Matcher java.util.regex.Matcher appendReplacement(java.lang.StringBuffer, java.lang.String) 0">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Matcher java.util.regex.Matcher appendReplacement(java.lang.StringBuffer, java.lang.String) 1">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Matcher java.util.regex.Matcher appendReplacement(java.lang.StringBuffer, java.lang.String)">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Matcher java.util.regex.Matcher region(int, int)">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Matcher java.util.regex.Matcher reset()">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Matcher java.util.regex.Matcher reset(java.lang.CharSequence)">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Matcher java.util.regex.Matcher useAnchoringBounds(boolean)">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Matcher java.util.regex.Matcher usePattern(java.util.regex.Pattern) 0">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Matcher java.util.regex.Matcher usePattern(java.util.regex.Pattern)">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Matcher java.util.regex.Matcher useTransparentBounds(boolean)">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Matcher java.util.regex.Pattern pattern()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val val="pure=true"/>
    </annotation>
  </item>
  <item name="java.util.regex.Pattern boolean access$200(int, int, int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val val="pure=true"/>
    </annotation>
  </item>
  <item name="java.util.regex.Pattern boolean access$400(java.util.regex.Matcher, int, java.lang.CharSequence) 0">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern boolean findSupplementary(int, int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val val="pure=true"/>
    </annotation>
  </item>
  <item name="java.util.regex.Pattern boolean has(int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val val="pure=true"/>
    </annotation>
  </item>
  <item name="java.util.regex.Pattern boolean hasBaseCharacter(java.util.regex.Matcher, int, java.lang.CharSequence) 0">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern boolean inRange(int, int, int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val val="pure=true"/>
    </annotation>
  </item>
  <item name="java.util.regex.Pattern boolean isLineSeparator(int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val val="pure=true"/>
    </annotation>
  </item>
  <item name="java.util.regex.Pattern boolean isSupplementary(int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val val="pure=true"/>
    </annotation>
  </item>
  <item name="java.util.regex.Pattern int access$300(java.lang.CharSequence, int, int) 0">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern int countChars(java.lang.CharSequence, int, int) 0">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern int countCodePoints(java.lang.CharSequence) 0">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern int cursor()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val val="pure=true"/>
    </annotation>
  </item>
  <item name="java.util.regex.Pattern int flags()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val val="pure=true"/>
    </annotation>
  </item>
  <item name="java.util.regex.Pattern int normalizeCharClass(java.lang.StringBuilder, int) 0">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern java.lang.String composeOneStep(java.lang.String) 0">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern java.lang.String composeOneStep(java.lang.String)">
    <annotation name="org.jetbrains.annotations.Nullable"/>
  </item>
  <item name="java.util.regex.Pattern java.lang.String groupname(int)">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern java.lang.String pattern()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val val="pure=true"/>
    </annotation>
  </item>
  <item name="java.util.regex.Pattern java.lang.String produceEquivalentAlternation(java.lang.String) 0">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern java.lang.String produceEquivalentAlternation(java.lang.String)">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern java.lang.String quote(java.lang.String) 0">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern java.lang.String quote(java.lang.String)">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern java.lang.String toString()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val val="pure=true"/>
    </annotation>
  </item>
  <item name="java.util.regex.Pattern java.lang.String[] producePermutations(java.lang.String) 0">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern java.lang.String[] producePermutations(java.lang.String)">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern java.util.regex.Matcher matcher(java.lang.CharSequence)">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern java.util.regex.Pattern compile(java.lang.String)">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern java.util.regex.Pattern compile(java.lang.String, int)">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern java.util.regex.Pattern.CharProperty access$600(int, int)">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern java.util.regex.Pattern.CharProperty bitsOrSingle(java.util.regex.Pattern.BitClass, int)">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern java.util.regex.Pattern.CharProperty caseInsensitiveRangeFor(int, int)">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern java.util.regex.Pattern.CharProperty charPropertyNodeFor(java.lang.String)">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern java.util.regex.Pattern.CharProperty intersection(java.util.regex.Pattern.CharProperty, java.util.regex.Pattern.CharProperty)">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern java.util.regex.Pattern.CharProperty newSingle(int)">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern java.util.regex.Pattern.CharProperty rangeFor(int, int)">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern java.util.regex.Pattern.CharProperty setDifference(java.util.regex.Pattern.CharProperty, java.util.regex.Pattern.CharProperty)">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern java.util.regex.Pattern.CharProperty unicodeBlockPropertyFor(java.lang.String) 0">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern java.util.regex.Pattern.CharProperty unicodeBlockPropertyFor(java.lang.String)">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern java.util.regex.Pattern.CharProperty unicodeScriptPropertyFor(java.lang.String) 0">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern java.util.regex.Pattern.CharProperty unicodeScriptPropertyFor(java.lang.String)">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern java.util.regex.Pattern.CharProperty union(java.util.regex.Pattern.CharProperty, java.util.regex.Pattern.CharProperty)">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern java.util.regex.Pattern.Node closure(java.util.regex.Pattern.Node)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val val="&quot;!null-&gt;!null&quot;"/>
    </annotation>
  </item>
  <item name="java.util.regex.Pattern java.util.regex.Pattern.Node createGroup(boolean)">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern java.util.regex.Pattern.Node expr(java.util.regex.Pattern.Node)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val val="&quot;!null-&gt;!null&quot;"/>
    </annotation>
  </item>
  <item name="java.util.regex.Pattern java.util.regex.Pattern.Node group0()">
    <annotation name="org.jetbrains.annotations.Nullable"/>
  </item>
  <item name="java.util.regex.Pattern java.util.regex.Pattern.Node newSlice(int[], int, boolean)">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern java.util.regex.Pattern.Node ref(int)">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern java.util.regex.Pattern.Node sequence(java.util.regex.Pattern.Node)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val val="&quot;!null-&gt;!null&quot;"/>
    </annotation>
  </item>
  <item name="java.util.regex.Pattern java.util.regex.PatternSyntaxException error(java.lang.String)">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern void printObjectTree(java.util.regex.Pattern.Node) 0">
    <annotation name="org.jetbrains.annotations.Nullable"/>
  </item>
  <item name="java.util.regex.Pattern void readObject(java.io.ObjectInputStream) 0">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern.1 boolean isSatisfiedBy(int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val val="pure=true"/>
    </annotation>
  </item>
  <item name="java.util.regex.Pattern.3 boolean isSatisfiedBy(int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val val="pure=true"/>
    </annotation>
  </item>
  <item name="java.util.regex.Pattern.4 boolean match(java.util.regex.Matcher, int, java.lang.CharSequence) 0">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern.4 boolean match(java.util.regex.Matcher, int, java.lang.CharSequence) 2">
    <annotation name="org.jetbrains.annotations.Nullable"/>
  </item>
  <item name="java.util.regex.Pattern.4 boolean match(java.util.regex.Matcher, int, java.lang.CharSequence)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val val="pure=true"/>
    </annotation>
  </item>
  <item name="java.util.regex.Pattern.All boolean isSatisfiedBy(int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val val="pure=true"/>
    </annotation>
  </item>
  <item name="java.util.regex.Pattern.BackRef boolean match(java.util.regex.Matcher, int, java.lang.CharSequence) 0">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern.BackRef boolean study(java.util.regex.Pattern.TreeInfo) 0">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern.Begin boolean match(java.util.regex.Matcher, int, java.lang.CharSequence) 0">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern.Behind boolean match(java.util.regex.Matcher, int, java.lang.CharSequence) 0">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern.BehindS boolean match(java.util.regex.Matcher, int, java.lang.CharSequence) 0">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern.BehindS boolean match(java.util.regex.Matcher, int, java.lang.CharSequence) 2">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern.BitClass boolean isSatisfiedBy(int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val val="pure=true"/>
    </annotation>
  </item>
  <item name="java.util.regex.Pattern.BitClass java.util.regex.Pattern.BitClass add(int, int)">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern.BmpCharProperty BmpCharProperty(java.util.regex.Pattern.1) 0">
    <annotation name="org.jetbrains.annotations.Nullable"/>
  </item>
  <item name="java.util.regex.Pattern.BmpCharProperty boolean match(java.util.regex.Matcher, int, java.lang.CharSequence) 0">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern.BnM boolean match(java.util.regex.Matcher, int, java.lang.CharSequence) 0">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern.BnM boolean study(java.util.regex.Pattern.TreeInfo) 0">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern.BnM java.util.regex.Pattern.Node optimize(java.util.regex.Pattern.Node)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val val="&quot;!null-&gt;!null;null-&gt;null&quot;"/>
    </annotation>
  </item>
  <item name="java.util.regex.Pattern.BnMS boolean match(java.util.regex.Matcher, int, java.lang.CharSequence) 0">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern.Bound boolean match(java.util.regex.Matcher, int, java.lang.CharSequence) 0">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern.Bound int check(java.util.regex.Matcher, int, java.lang.CharSequence) 0">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern.Branch boolean study(java.util.regex.Pattern.TreeInfo) 0">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern.Branch boolean study(java.util.regex.Pattern.TreeInfo)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val val="&quot;!null-&gt;false&quot;"/>
    </annotation>
  </item>
  <item name="java.util.regex.Pattern.BranchConn boolean study(java.util.regex.Pattern.TreeInfo) 0">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern.BranchConn boolean study(java.util.regex.Pattern.TreeInfo)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val val="pure=true"/>
    </annotation>
  </item>
  <item name="java.util.regex.Pattern.CIBackRef boolean match(java.util.regex.Matcher, int, java.lang.CharSequence) 0">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern.CIBackRef boolean study(java.util.regex.Pattern.TreeInfo) 0">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern.Caret boolean match(java.util.regex.Matcher, int, java.lang.CharSequence) 0">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern.CharProperty CharProperty(java.util.regex.Pattern.1) 0">
    <annotation name="org.jetbrains.annotations.Nullable"/>
  </item>
  <item name="java.util.regex.Pattern.CharProperty boolean match(java.util.regex.Matcher, int, java.lang.CharSequence) 0">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern.CharProperty boolean study(java.util.regex.Pattern.TreeInfo) 0">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern.CharProperty java.util.regex.Pattern.CharProperty complement()">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern.CharPropertyNames CharPropertyNames()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val val="pure=true"/>
    </annotation>
  </item>
  <item name="java.util.regex.Pattern.CharPropertyNames java.util.regex.Pattern.CharProperty charPropertyFor(java.lang.String)">
    <annotation name="org.jetbrains.annotations.Nullable"/>
  </item>
  <item name="java.util.regex.Pattern.CharPropertyNames.1 java.util.regex.Pattern.CharProperty make()">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern.CharPropertyNames.2 java.util.regex.Pattern.CharProperty make()">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern.CharPropertyNames.22 boolean isSatisfiedBy(int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val val="pure=true"/>
    </annotation>
  </item>
  <item name="java.util.regex.Pattern.CharPropertyNames.3 java.util.regex.Pattern.CharProperty make()">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern.CharPropertyNames.5 5()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val val="pure=true"/>
    </annotation>
  </item>
  <item name="java.util.regex.Pattern.CharPropertyNames.5 java.util.regex.Pattern.CharProperty make()">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern.CharPropertyNames.CharPropertyFactory CharPropertyFactory()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val val="pure=true"/>
    </annotation>
  </item>
  <item name="java.util.regex.Pattern.CharPropertyNames.CharPropertyFactory CharPropertyFactory(java.util.regex.Pattern.1) 0">
    <annotation name="org.jetbrains.annotations.Nullable"/>
  </item>
  <item name="java.util.regex.Pattern.CharPropertyNames.CharPropertyFactory CharPropertyFactory(java.util.regex.Pattern.1)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val val="pure=true"/>
    </annotation>
  </item>
  <item name="java.util.regex.Pattern.CharPropertyNames.CloneableProperty CloneableProperty(java.util.regex.Pattern.1) 0">
    <annotation name="org.jetbrains.annotations.Nullable"/>
  </item>
  <item name="java.util.regex.Pattern.Conditional boolean study(java.util.regex.Pattern.TreeInfo) 0">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern.Ctype boolean isSatisfiedBy(int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val val="pure=true"/>
    </annotation>
  </item>
  <item name="java.util.regex.Pattern.Curly boolean study(java.util.regex.Pattern.TreeInfo) 0">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern.Dollar boolean match(java.util.regex.Matcher, int, java.lang.CharSequence) 0">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern.Dollar boolean study(java.util.regex.Pattern.TreeInfo) 0">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern.Dot boolean isSatisfiedBy(int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val val="pure=true"/>
    </annotation>
  </item>
  <item name="java.util.regex.Pattern.End boolean match(java.util.regex.Matcher, int, java.lang.CharSequence) 0">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern.First boolean study(java.util.regex.Pattern.TreeInfo) 0">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern.GroupCurly boolean match(java.util.regex.Matcher, int, java.lang.CharSequence) 0">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern.GroupCurly boolean match0(java.util.regex.Matcher, int, int, java.lang.CharSequence) 0">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern.GroupCurly boolean study(java.util.regex.Pattern.TreeInfo) 0">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern.GroupHead boolean match(java.util.regex.Matcher, int, java.lang.CharSequence) 0">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern.GroupHead boolean matchRef(java.util.regex.Matcher, int, java.lang.CharSequence) 0">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern.GroupRef boolean match(java.util.regex.Matcher, int, java.lang.CharSequence) 0">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern.GroupRef boolean study(java.util.regex.Pattern.TreeInfo) 0">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern.GroupTail boolean match(java.util.regex.Matcher, int, java.lang.CharSequence) 0">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern.LastMatch boolean match(java.util.regex.Matcher, int, java.lang.CharSequence) 0">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern.LastNode boolean match(java.util.regex.Matcher, int, java.lang.CharSequence) 0">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern.LastNode boolean match(java.util.regex.Matcher, int, java.lang.CharSequence) 2">
    <annotation name="org.jetbrains.annotations.Nullable"/>
  </item>
  <item name="java.util.regex.Pattern.LazyLoop boolean match(java.util.regex.Matcher, int, java.lang.CharSequence) 0">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern.LazyLoop boolean matchInit(java.util.regex.Matcher, int, java.lang.CharSequence) 0">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern.LazyLoop boolean study(java.util.regex.Pattern.TreeInfo) 0">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern.LazyLoop boolean study(java.util.regex.Pattern.TreeInfo)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val val="&quot;!null-&gt;false&quot;"/>
    </annotation>
  </item>
  <item name="java.util.regex.Pattern.Loop boolean match(java.util.regex.Matcher, int, java.lang.CharSequence) 0">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern.Loop boolean matchInit(java.util.regex.Matcher, int, java.lang.CharSequence) 0">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern.Loop boolean study(java.util.regex.Pattern.TreeInfo) 0">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern.Loop boolean study(java.util.regex.Pattern.TreeInfo)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val val="&quot;!null-&gt;false&quot;"/>
    </annotation>
  </item>
  <item name="java.util.regex.Pattern.Neg boolean match(java.util.regex.Matcher, int, java.lang.CharSequence) 0">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern.Node boolean match(java.util.regex.Matcher, int, java.lang.CharSequence) 0">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern.Node boolean match(java.util.regex.Matcher, int, java.lang.CharSequence) 2">
    <annotation name="org.jetbrains.annotations.Nullable"/>
  </item>
  <item name="java.util.regex.Pattern.Node boolean match(java.util.regex.Matcher, int, java.lang.CharSequence)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val val="&quot;!null,_,_-&gt;true;_,_,!null-&gt;true;_,_,null-&gt;true&quot;"/>
    </annotation>
  </item>
  <item name="java.util.regex.Pattern.NotBehind boolean match(java.util.regex.Matcher, int, java.lang.CharSequence) 0">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern.NotBehindS boolean match(java.util.regex.Matcher, int, java.lang.CharSequence) 0">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern.NotBehindS boolean match(java.util.regex.Matcher, int, java.lang.CharSequence) 2">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern.Pos boolean match(java.util.regex.Matcher, int, java.lang.CharSequence) 0">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern.Prolog boolean match(java.util.regex.Matcher, int, java.lang.CharSequence) 0">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern.Prolog boolean study(java.util.regex.Pattern.TreeInfo) 0">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern.Single boolean isSatisfiedBy(int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val val="pure=true"/>
    </annotation>
  </item>
  <item name="java.util.regex.Pattern.SingleI boolean isSatisfiedBy(int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val val="pure=true"/>
    </annotation>
  </item>
  <item name="java.util.regex.Pattern.SingleS boolean isSatisfiedBy(int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val val="pure=true"/>
    </annotation>
  </item>
  <item name="java.util.regex.Pattern.SliceIS int toLower(int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val val="pure=true"/>
    </annotation>
  </item>
  <item name="java.util.regex.Pattern.SliceNode boolean study(java.util.regex.Pattern.TreeInfo) 0">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern.Start boolean match(java.util.regex.Matcher, int, java.lang.CharSequence) 0">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern.Start boolean study(java.util.regex.Pattern.TreeInfo) 0">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern.Start boolean study(java.util.regex.Pattern.TreeInfo)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val val="&quot;!null-&gt;false&quot;"/>
    </annotation>
  </item>
  <item name="java.util.regex.Pattern.StartS boolean match(java.util.regex.Matcher, int, java.lang.CharSequence) 0">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern.UnixCaret boolean match(java.util.regex.Matcher, int, java.lang.CharSequence) 0">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern.UnixDollar boolean match(java.util.regex.Matcher, int, java.lang.CharSequence) 0">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern.UnixDollar boolean study(java.util.regex.Pattern.TreeInfo) 0">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.Pattern.UnixDot boolean isSatisfiedBy(int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val val="pure=true"/>
    </annotation>
  </item>
  <item name="java.util.regex.PatternSyntaxException int getIndex()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val val="pure=true"/>
    </annotation>
  </item>
  <item name="java.util.regex.PatternSyntaxException java.lang.String getDescription()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val val="pure=true"/>
    </annotation>
  </item>
  <item name="java.util.regex.PatternSyntaxException java.lang.String getMessage()">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.PatternSyntaxException java.lang.String getPattern()">
    <annotation name="org.jetbrains.annotations.Contract">
      <val val="pure=true"/>
    </annotation>
  </item>
  <item name="java.util.regex.UnicodeProp UnicodeProp(java.lang.String, int, java.util.regex.UnicodeProp.1) 2">
    <annotation name="org.jetbrains.annotations.Nullable"/>
  </item>
  <item name="java.util.regex.UnicodeProp java.util.regex.UnicodeProp forName(java.lang.String) 0">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.UnicodeProp java.util.regex.UnicodeProp forName(java.lang.String)">
    <annotation name="org.jetbrains.annotations.Nullable"/>
  </item>
  <item name="java.util.regex.UnicodeProp java.util.regex.UnicodeProp forPOSIXName(java.lang.String) 0">
    <annotation name="org.jetbrains.annotations.NotNull"/>
  </item>
  <item name="java.util.regex.UnicodeProp java.util.regex.UnicodeProp forPOSIXName(java.lang.String)">
    <annotation name="org.jetbrains.annotations.Nullable"/>
  </item>
  <item name="java.util.regex.UnicodeProp.12 boolean is(int)">
    <annotation name="org.jetbrains.annotations.Contract">
      <val val="pure=true"/>
    </annotation>
  </item>
</root>
